
#import os
import random
import numpy as np
import cv2

from collections import namedtuple
#from tqdm.notebook import tqdm

from typing import List


SHAPE_TYPES = [ 'square', 'circle', 'triangle' ]
SHAPE_COLORS = [ (255,0,0), (0,255,0), (0,0,255) ]


Shape = namedtuple('Shape', ['type', 'color'])


def draw_shape(im, shape, shape_size, pos, rot=0, outline=None):
    rot_mat = np.array([[np.cos(rot), -np.sin(rot)],
                        [np.sin(rot),  np.cos(rot)]])

    radius = shape_size / 2
    center = np.array(pos) + radius

    if shape.type == 'square':
        points = ((np.array([
            (-1, 0), (0, 1), (1, 0), (0, -1),
        ]) @ rot_mat.T) * radius + center).round().astype(int)
        cv2.fillConvexPoly(im, points, shape.color)
        if outline is not None:
            cv2.polylines(im, [points], True, outline)
    elif shape.type == 'circle':
        center = tuple(center.round().astype(int))
        cv2.circle(im, center, round(radius), shape.color, -1)
        if outline is not None:
            cv2.circle(im, center, round(radius), outline)
    elif shape.type == 'triangle':
        points = ((np.array([
            (1, 0), (-0.5, 0.8660254), (-0.5, -0.8660254),
        ]) @ rot_mat.T) * radius + center).round().astype(int)
        cv2.fillConvexPoly(im, points, shape.color)
        if outline is not None:
            cv2.polylines(im, [points], True, outline)
    else:
        raise Exception(f'unsupported/invalid shape type "{shape.type}"')


def draw_shapes(im, shapes, shape_scale=0.2, outline=None):
    im_size = im.shape[0]
    shape_size = im_size * shape_scale

    for shape in shapes:
        pos = np.random.rand(2) * (im_size-shape_size)
        rot = np.random.rand() * np.pi
        draw_shape(im, shape, shape_size, pos, rot, outline)


def pick_random_color():
    return tuple(random.randint(0, 255) for _ in range(3))


def to_pytorch_inputs(x1, x2, y, device=None):
    import torch

    X = np.concatenate([x1, x2]) / 256
    X = X.transpose(0, 3, 1, 2)
    y = np.concatenate([y, y])

    X = torch.from_numpy(X).to(torch.float32).to(device)
    y = torch.from_numpy(y).to(torch.float32).to(device)

    return X, y


class ShapeData():
    """Simple shape data source of image pairs with same/diff labels

    The parameters for constructor define what images generated by this data
    source look like. TODO: document me! (describe dataset, task)

    Args:
        batch_size: Number of image pairs to create at a time
        im_size: Size of the generated images
        shape_scale: Fraction of (shape size)/(image size)
        min_shapes: Minimum number of shapes in each image
        max_shapes: Maximum number of shapes in each image
        outline: Outline color for shapes
        shape_types: List of possible shape type strings, randomly sampled
            for every generated shape
        shape_colors: Defines shape colors. Either a 0-argument function
            returning a ([0-255],[0-255],[0-255]) color tuple or a list.
            If a function, it's called to pick the color for each shape.
            If a list, it's randomly sampled for each shape.
    """

    def __init__(self, batch_size:int, im_size:int, shape_scale:float=0.2,
                 min_shapes:int=1, max_shapes:int=5, outline=None,
                 shape_types=SHAPE_TYPES, shape_colors=SHAPE_COLORS):
        self.batch_size = batch_size
        self.im_size = im_size
        self.shape_scale = shape_scale
        self.min_shapes = min_shapes
        self.max_shapes = max_shapes
        self.outline = outline

        self.shape_types = shape_types
        if type(shape_colors) is list:
            self.shape_color_f = lambda: random.choice(shape_colors)
        else:
            self.shape_color_f = shape_colors

    def create_batch(self, same_p:float=0.5, shapes:List[Shape]=None):
        """Create a batch of image pairs along with same/diff labels.

        Args:
            same_p: Probability that images in an image pair are the same
            shapes: If provided, list of shapes to draw in images in batch.
                same_p is ignored in that case, as all images are the same.
                If None, randomly picks lists of shapes per image/pair.

        Returns:
            (x1, x1_shapes), (x2, x2_shapes), y
            x# (numpy uint8 arrays of shape [N, S, S, 3]): Generated images
            x#_shapes (List[List[Shape]]): Shapes present in each image
            y (numpy float32 array of shape [N]): labels per image pair
        """
        image_shape = (self.batch_size, self.im_size, self.im_size, 3)
        x1 = np.zeros(image_shape, np.uint8)
        x2 = np.zeros(image_shape, np.uint8)
        y = np.zeros(self.batch_size, np.float32)
        x1_shapes = []
        x2_shapes = []

        for i in range(self.batch_size):
            if shapes is None:
                shapes1 = shapes2 = self.select_shape_list()
                if random.random() < same_p:
                    y[i] = 1
                else:
                    y[i] = 0
                    # NOTE: infinite loop if only one shape list possible
                    while shapes2 == shapes1:
                        shapes2 = self.select_shape_list()
            else:
                shapes1 = shapes2 = shapes

            draw_shapes(x1[i], shapes1, self.shape_scale, outline=self.outline)
            draw_shapes(x2[i], shapes2, self.shape_scale, outline=self.outline)
            x1_shapes.append(shapes1)
            x2_shapes.append(shapes2)

        return (x1, x1_shapes), (x2, x2_shapes), y

    def select_shape_list(self):
        """Utility function to select a list of shapes. """
        count = random.randint(self.min_shapes, self.max_shapes)
        return [self.select_shape() for _ in range(count)]

    def select_shape(self):
        """Utility function to select a single shape. """
        shape_type = random.choice(self.shape_types)
        shape_color = self.shape_color_f()
        return Shape(type=shape_type, color=shape_color)





